package с6_types

import kotlin_in_action.JavaPerson

/**
 * ## 6.2. Примитивные и другие базовые типы.
 *
 * ## Ненуллабельные примитивные типы.
 * Java различает примитивные и ссылочные типы.
 * Переменная примитивного типа непосредственно содержит своё значение (в стеке).
 * Переменная ссылочного типа содержит ссылку на область памяти, где хранится объект (куча).
 *
 * Значения примитивных типов можно хранить и передавать более эффективно,
 * но они не имеют методов и их нельзя хранить в коллекциях (использовать в дженериках).
 *
 * Kotlin не различает примитивных типов и типов обёрток.
 * В большинстве случаев примитивы котлина (Int) компилируются в примитивные типы Java (int), исключение - дженерики.
 * Если примитив используется как аргумент обобщённого типа, он скомпилируется в соответсвующую обёртку на Java (Integer).
 *
 * ## Нуллабельные примитивные типы.
 * Значение null в Java может храниться только у ссылочных типов, поэтому все нуллабельные примитивы компилируются
 * в классы обёртки на Java (Int? -> Integer).
 */

fun main() {
    /**
     * ## Числовые преобразования.
     * Kotlin не выполняет автоматического преобразования чисел из одного типа в другой.
     */
    val i = 1
    // val l: Long = i <- Type mismatch!
    // Нужно применить явное преобразование:
    val l: Long = i.toLong()

    // При этом литералы преобразуются автоматически:
    val sum = 5L + 2 + 4.4f + 5L + 5.55

    // Преобразование строк:
    val isTrue: Boolean = "true".toBoolean()
    val five: Int = "5".toInt()
    // val x: Int = "x".toInt() <- NumberFormatException

    /**
     * ## Корневые типы Any и Any?
     * Any(?) - аналог Object (супертип всех ссылочных типов).
     * Object рассматривается в Kotlin как Any(?) (платформенный тип - нуллабельность не известна).
     * Any компилируется в Object в байт-коде.
     * Any имеет только 3 метода: toString, equals, hashCode.
     * Чтобы получить доступ к другим методам Object, можно привести к Object в ручную.
     */
    val anyObject: Any = Any()
    val anyObjectExtended = anyObject as Object
    anyObject.notify()

    /**
     * Тип Unit - аналог void, используется в качестве типа возвращаемого значения функций которые не возвращают ничего (нет return...).
     * fun f(): Unit {} == fun f() {}
     * Но в отличие от void Unit - это полноценный тип (и одновременно единственный экземпляр этого типа), который может
     * использоваться как аргумент обобщённого типа.
     */
    class NoResultProcessor : Processor<Unit> {
        override fun process() {
            // return Unit - добавляется в скомпилированном коде, он возвращается неявно.
        }
    }

    /**
     * ## Тип Nothing.
     * Для некоторых типов не имеет смысла понятие возвращаемого значения, тк они никогда не возвращаются.
     * Такая функция не возвращает управления и помечется специальным типом Nothing.
     */
    fun fail(message: String): Nothing {
        throw IllegalStateException(message)
    }

    fun runEndlessLoop(): Nothing {
        while (true) {}
    }

    /**
     * Nothing - неявно является наследником всех типов, поскольку компилятор знает, что функция, возвращающая Nothing
     * не вернёт управления.
     */
    val name = JavaPerson("Bob").name ?: fail("name == null") //Nothing - значение по умолчанию для name: String?
    // Это также объясняет почему можно сделать так:
    fun convertToInt(string: String): Int {
        return if(string.isNotEmpty()) {
            string.toInt() // Int
        } else {
            throw IllegalArgumentException("empty string") // Nothing
        }
    }
}

interface Processor<T> {
    fun process(): T
}