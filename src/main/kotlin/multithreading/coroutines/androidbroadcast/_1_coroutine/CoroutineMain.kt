package multithreading.coroutines.androidbroadcast._1_coroutine

import kotlinx.coroutines.*
import kotlin.random.Random

/**
 * ## 1 Что такое корутина.
 *
 * Корутины позволяют выполнять асинхронные операции, которые могут быть приостановленны, а позже продолжить своё выполнение.
 * Корутины сравнивают с потоками, но это не верно. Потоки применяются для организации многозадачности, корутины же предоставляют лишь асинхронные операции, но не выполняются параллельно.
 * Параллельность не является частью понятия "корутины". Их преимущество - лёгкость вызова без необходимости системных вызовов и блокирующих операций.
 * Корутина не привязана к потоку: она может приостановить выполнение в одном потоке, а возобновить в другом.
 *
 * ## Асинхронность VS Параллельность.
 * Асинхронность: события происходят независимо от главного потока. Способ взаимодействия с главным потоком не является последовательным, а происходит через коллбеки.
 * (Пример: Android Main Thread: Handler & Looper - операции кладутся в очередь и выполняются в рамках одного потока). Параллельного выполнения в рамках одного потока нет.
 * Параллельность: множество операций происходит одновременно (например, в разных ядрах процессора).
 *
 * Корутины позволяют писать асинхронный код (с коллбеками) в синхронном стиле (без использования коллбеков):
 *
 *      //Асинхронный стиль
 *      remoteCall { data ->
 *          storeData(data) {
 *              println(data)
 *          }
 *      }
 *
 *      //Синхронный стиль
 *      val data = remoteCall()
 *      storeData(data)
 *      println(data)
 *
 * Сложный код можно упростить (без callback hell).
 *
 * Корутины не являются частью стандартной библиотеки языка. Есть лишь ключевое слово suspend.
 * suspend-функция не может быть вызвана из обычной функции, тк она возращает свой ответ асинхронно.
 * suspend-функцию можно вызвать только из другой suspend-функции или корутины, которые создаются через coroutine-билдеры.
 *
 * Continuation можно рассматривать как коллбек, который будет вызван по окончанию выполнения тела функции.
 *
 *      suspend fun doWork() {
 *          // долгая работа
 *      }
 *
 *      //Под капотом
 *      fun doWork(completion: Continuation<Unit>) {...}
 *
 * Kotlin-компилятор превращает код корутин в стейт-машину (длинный switch-case, где каждый кейс соответсвует какому-то вызову suspend-функции).
 *
 * Scopes.
 * Корутины позволяют получить данные и вывести на экран. Если пользователь закрыл экран, то результат операции больше не нужен, и корутину следует остановить.
 * Как отслеживать все подобные операции? (В RxJava нужно было хранить ссылки Disposable). Но в корутинах сделано уменее: каждая корутина привязана к какому-то жизненному циклу (к времени жизни Scope).
 * Любая корутина привязана к какому-то CoroutineScope.
 *
 * Остановка (отмена) корутины.
 * Чтобы корректно остановить Java-поток, нужно вызвать метод interrupt() у потока, затем проверять в коде потока isInterrupted и останавливать выполнение операции в потоке самостоятельно.
 * Корутины работают по похожей схеме, но с одним исключением: состояние корутины проверяется перед тем как продолжить её выполнение после прерывания (перед вызовом любой suspend-функции корутина может быть остановлена).
 *
 * Пример suspend-функции:
 */
suspend fun doWork(name: String): String {
    delay(Random.nextLong(5000))
    return "Done. $name"
}

fun main(): Unit = runBlocking { // Scope - является "точкой входа мир корутин"
    repeat(100) {
        launch { // корутин билдер launch создаёт корутину
            val result = doWork("Coroutine`s result $it")
            println(result)
        }
    }
    //Done. Coroutine`s result 34
    //Done. Coroutine`s result 23
    //Done. Coroutine`s result 0
    //... выполняются в разнобой и быстро (параллельно)

    // Если выполнить подобный вызов suspend-функций без создания корутин
//    repeat(100) {
//        val result = doWork("Coroutine`s result $it")
//        println(result)
//    }
    //Done. Coroutine`s result 2
    //Done. Coroutine`s result 3
    //Done. Coroutine`s result 4
    //... выполняются последовательно и долго (suspend-функции выполняются последовательно: пока не выполнится предыдущий вызов, не начнётся следующий).
    // suspend-функция не запускается пока до неё не дойдёт очередь.

    // Корутины по умолчанию запускаются сразу после создания.
    // Но можно поменять режим запуска (например, при start = CoroutineStart.LAZY выполнение будет как у suspend-функций).
    val coroutines: List<Deferred<String>> = List(100) {
        async {
            doWork("Async result $it")
        }
    }
    coroutines.forEach { println(it.await()) }
    //Done. Async result 0
    //Done. Async result 1
    //Done. Async result 2
    //... выполняются быстро и последовательно

}