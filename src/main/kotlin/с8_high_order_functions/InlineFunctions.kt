package с8_high_order_functions

import java.util.concurrent.locks.Lock
import java.util.concurrent.locks.ReentrantLock

/**
 * ## 8.2. inline (встраиваемые) функции: устранение накладных расходов лямбда-выражений.
 * Лямбда-выражения компилируются в анонимные классы - каждый раз, когда используется лямбда выражения,
 * создаётся объект анонимного класса; а если лямбда захватывает переменные, для каждого вызова создаётся новый объект.
 * Это влечёт дополнительные расходы ресурсов.
 * Если отметить функцию модификатором "inline", компилятор не будет генерировать вызов функции в месте её использования,
 * а просто вставит в месте её вызова код её реализации.
 */
inline fun <T> synchronized(lock: Lock, action: () -> T): T {
    lock.lock()
    try {
        return action() // <- место вызова лямбды
    } finally {
        lock.unlock()
    }
}

fun main() {
    val lock = ReentrantLock()

    fun foo(lock: Lock) {
        println("Before sync")
        synchronized(lock) { // <- вызов inline функции
            println("Action")
        }
        println("After sync")
    }

    foo(lock)

    /**
     * Данный код скомпилируется примерно так:
     *
     *     fun __foo__(lock: Lock) {
     *         println("Before sync")
     *
     *         lock.lock()  <- код, встраиваемый вместо вызова synchronized
     *          try {
     *             println("Action") <- код, лямбды внутри synchronized тоже встраивается!
     *          } finally {
     *               lock.unlock()
     *          }
     *
     *         println("After sync")
     *     }
     *
     * Важно: встраивается не только реализация inline-функции synchronized, но лямбда, которая передаётся внутри synchronized (action).
     *
     * Однако, если лямбда будет отсутствовать в точке вызова inline-функции, подобного встраивания не произойдёт:
     */
    fun runUnderLock(lock: Lock, body: () -> Unit) {
        synchronized(lock, body) // <- лямбда передаётся параметром функционального типа
    }
    /**
     * Функция с подобным вызовом скомпилируется так:
     */
    fun __runUnderLock__(lock: Lock, body: () -> Unit) {
        lock.lock()
        try {
            body() // <- встраивания лямбды внутри synchronized не происходит
        } finally {
            lock.unlock()
        }
    }

    /**
     * ## Ограничения встраиваемых функций.
     * Не все функции, использующие лямбда-выражения, могут быть встраиваемыми.
     * В inline-функции тело лямбды, переданной в аргумент inline-функции, встраивается непосредственно в код.
     * Это ограничивает возможные варианты использования соответствующего параметра в теле inline-функции.
     *
     * Если функция, переданная в качестве параметра inline-функции, вызывается внутри inline-функции - она может быть встроена.
     * Но если параметр сохраняется для последующего использования и не вызывается, код лямбды невозможно встроить,
     * потому что должен существовать объект (анонимного класса), содержащий этот код в своём методе. Иначе компилятор выдаст ошибку: "Illegal usage of inline-parameter".
     * Соответсвующее параметры inline-функции следует помечать noinline (невстраиваемый).
     *
     *     inline fun bar(inlined: () -> Unit, noinline notInlined: () -> Unit) {
     *          inlined() <- есть вызов
     *          Foo(param = notInlined) <- нет вызова
     *          ...
     *     }
     *
     * ## Когда стоит использовать inline-функции?
     * inline способно повысить производительность почти только функций, принимающих лямбда-выражения. В остальных случаях, следуют оценить выгоды.
     * Для вызовов обычных функций JVM использует автоматический механизм встраивания, если это даёт преимущество.
     * В байт-коде реализация функций присутствует в единственном экземпляре и её не требуется копировать во все точки вызова (как в случае с inline).
     *
     * Если inline-функция велика, копирование её байт-кода во все точки вызова может существенно увеличить общий размер байт-кода.
     */
    class Doc

}