package с9_generics

/**
 * # 9. Обобщённые типы.
 * Основные идеи обобщённых типов в Kotlin напоминаю Java.
 *
 * Поддержка обобщённых типов даёт возможность определить параметризованные типы.
 * Когда создаётся экземпляр такого типа, параметр типа заменяется конкретным аргументом, который называется типовым аргументом.
 * Например, класс Map<K, V> можно инициализировать конкретными аргументами Map<String, Person> - синтаксис как в Java.
 *
 * Нововведения:
 * - Овеществляемые типовые параметры (reified type parameters) - позволяют ссылаться во время выполнения на конкретные типы,
 * используемые как типовые аргументы в вызовах встраиваемых функций. (Для обычных классов и функций это невозможно, тк типовые
 * аргументы стираются во время выполнения).
 * - Определение вариантности в месте объявления (declaration-site variance) - позволяет указать, является ли обобщенный тип,
 * имеющий типовой аргумент, подтипом или супертипом другого обобщённого типа с тем же базовым типом и другим типовым аргументом.
 * - Определение вариантности в месте использования (use-site variance) преследует ту же цель для конкретного использования
 * обобщенного типа (решает те же задачи, что и wildcard в Java).
 *
 * ## Обобщённые функции и свойство
 *
 * Типовые параметры можно объявлять для методов классов или интерфейсов, функций верхнего уровня и функций расширений.
 * А также можно объявлять обобщённые свойство-расширения.
 */
fun <T> List<T>.slice(indices: IntRange): List<T> {
    return this.subList(indices.first, indices.last)
}

private fun example1() {
    val letters = ('a'..'z').toList()
    println(letters.slice<Char>(0..2)) // [a, b]
    println(letters.slice(10..12)) // <- Компилятор сам определяет тип аргумента
}

/**
 * Можно объявлять обобщённые свойство-расширения.
 */
val <T> List<T>.penultimate: T
    get() = this[size - 2]

/**
 * Но нельзя объявить обобщённое свойство, не являющееся расширением
 * - нельзя сохранить несколько значений разных типов в свойстве класса.
 */
class Bar {
   // val <T> x: T = TODO() // ERROR: Type parameter of a property must be used in its receiver type
}

/**
 * ## Объявление обобщённых классов.
 * В обобщённых классах и интерфейсах типовые параметры можно использовать в теле класса.
 */
interface MyList<T> {
    operator fun get(index: Int): T // T можно использовать внутри интерфейса или класса как обычный тип
    // ...
}

/**
 * Ограничения типовых параметров позволяют ограничивать количество допустимых типов, которые можно использовать
 * в качестве типовых аргументов.
 * Тут Number является верхней границей (в иерархии классов): в качестве типовых аргументов могут быть переданы только подклассы Number.
 */
fun <T : Number> List<T>.sum(): T {
    first().toDouble() // <- Так можно, потому что toDouble объявлен в классе Number
    return sum()
}

/**
 * Если нужно определить несколько ограничений для типового параметра, используется ключевое слово "where":
 */
fun <T> ensureTrailingPeriod(seq: T) where T : CharSequence, T: Appendable {
    if (!seq.endsWith('.')) { //<- вызов функции из CharSequence
        seq.append('.') //<- вызов функции из Appendable
    }
}

/**
 * Вместо типового параметра может быть подставлен нуллабельный типовой аргумент.
 */
class Processor<T> { //чтобы гарантировать ненуллабельность, нужно ограничить <T : Any>
    fun process(value: T) {
        value?.hashCode() //<- value можно использовать как nullable
    }
}
val nullableProcessor = Processor<String?>()

fun main() {
    example1()
}